function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var XYPoint = function XYPoint(x, y) {
  _classCallCheck(this, XYPoint);

  this.x = x;
  this.y = y;
};

/*
 * XY utilities. Many of the methods, as marked, were adapted from Bryan Johnson's work (http://bit.ly/2bHHjxd)
 */

var XYUtil = /*#__PURE__*/function () {
  function XYUtil() {
    _classCallCheck(this, XYUtil);
  }

  _createClass(XYUtil, null, [{
    key: "crossProduct",

    /**
     * Returns the cross product of two XYPoints.
     *
     * @author Bryan Johnson [original], Todd Dukart [conversion]
     *
     * @param {XYPoint} p1 Point 1.
     * @param {XYPoint} p2 Point 2.
     * @return {Number} Cross-product of the two XYPoints provided.
     */
    value: function crossProduct(p1, p2) {
      return p1.x * p2.y - p1.y * p2.x;
    }
    /**
     * Find the closest point on a line. This point will be reproducible by a Hue lamp.
     *
     * @author Bryan Johnson [original], Todd Dukart [conversion]
     *
     * @param {XYPoint} start The point where the line starts.
     * @param {XYPoint} end The point where the line ends.
     * @param {XYPoint} point The point which is close to the line.
     * @return {XYPoint} A point that is on the line, and closest to the XYPoint provided.
     */

  }, {
    key: "getClosestPointOnLine",
    value: function getClosestPointOnLine(start, end, point) {
      var AP = new XYPoint(point.x - start.x, point.y - start.y);
      var AB = new XYPoint(end.x - start.x, end.y - start.y);
      var ab2 = AB.x * AB.x + AB.y * AB.y;
      var ap_ab = AP.x * AB.x + AP.y * AB.y;
      var t = ap_ab / ab2;

      if (t < 0.0) {
        t = 0.0;
      } else if (t > 1.0) {
        t = 1.0;
      }

      return new XYPoint(start.x + AB.x * t, start.y + AB.y * t);
    }
    /**
     * Returns the distance between two XYPoints.
     *
     * @author Bryan Johnson [original], Todd Dukart [conversion]
     *
     * @param {XYPoint} p1 The first point.
     * @param {XYPoint} p2 The second point.
     * @return {Number} The distance between points one and two.
     */

  }, {
    key: "getDistanceBetweenTwoPoints",
    value: function getDistanceBetweenTwoPoints(p1, p2) {
      // horizontal difference
      var dx = p1.x - p2.x; // vertical difference

      var dy = p1.y - p2.y;
      return Math.sqrt(dx * dx + dy * dy);
    }
  }]);

  return XYUtil;
}();

var Red = new XYPoint(0.675, 0.322),
    Lime = new XYPoint(0.4091, 0.518),
    Blue = new XYPoint(0.167, 0.04);
/**
 * Fit a number into a range from 0 to `max`.
 * @param {number} number
 * @param {number} max
 * @returns {number}
 */

var fitIntoRange = function fitIntoRange(number, max) {
  // Convert the hue to a valid value, 0 to 360.
  if (number >= max) {
    number = number % max;
  } else if (number < 0) {
    number = number + max * Math.floor(number / (0 - max));
  }

  return number;
};
/*
 * Color utilities. Many of the methods, as marked, were adapted from Bryan Johnson's work (http://bit.ly/2bHHjxd),
 * which itself was derived from Q42's C# Hue library (http://bit.ly/2bye7ul).
 */


var ColorUtil = /*#__PURE__*/function () {
  function ColorUtil() {
    _classCallCheck(this, ColorUtil);
  }

  _createClass(ColorUtil, null, [{
    key: "isInLampsReach",

    /**
     * Check if the point can be recreated by a Hue lamp.
     *
     * @author Q42 [original C#] Bryan Johnson [original JavaScript], Todd Dukart [conversion]
     *
     * @param {XYPoint} point The point to test
     * @returns {boolean} Flag indicating if the point is within reproducible range.
     */
    value: function isInLampsReach(point) {
      var v1 = new XYPoint(Lime.x - Red.x, Lime.y - Red.y);
      var v2 = new XYPoint(Blue.x - Red.x, Blue.y - Red.y);
      var q = new XYPoint(point.x - Red.x, point.y - Red.y);
      var s = XYUtil.crossProduct(q, v2) / XYUtil.crossProduct(v1, v2);
      var t = XYUtil.crossProduct(v1, q) / XYUtil.crossProduct(v1, v2);
      return s >= 0.0 && t >= 0.0 && s + t <= 1.0;
    }
    /**
     * Get the closest point that can be recreated by a Hue lamp.
     *
     * @author Bryan Johnson [original], Todd Dukart [conversion]
     *
     * @param {XYPoint} point The point to test
     * @returns {XYPoint} The closest point that can be recreated by a Hue lamp.
     */

  }, {
    key: "getClosestReproduciblePoint",
    value: function getClosestReproduciblePoint(point) {
      // Color is unreproducible, find the closest point on each line in the CIE 1931 'triangle'.
      var pAB = XYUtil.getClosestPointOnLine(Red, Lime, point);
      var pAC = XYUtil.getClosestPointOnLine(Blue, Red, point);
      var pBC = XYUtil.getClosestPointOnLine(Lime, Blue, point); // Get the distances per point and see which point is closer to our Point.

      var dAB = XYUtil.getDistanceBetweenTwoPoints(point, pAB);
      var dAC = XYUtil.getDistanceBetweenTwoPoints(point, pAC);
      var dBC = XYUtil.getDistanceBetweenTwoPoints(point, pBC);
      var lowest = dAB;
      var closestPoint = pAB;

      if (dAC < lowest) {
        lowest = dAC;
        closestPoint = pAC;
      }

      if (dBC < lowest) {
        lowest = dBC;
        closestPoint = pBC;
      }

      return closestPoint;
    }
    /**
     * Parses a valid hex color string and returns the Red RGB integer value.
     *
     * @author Bryan Johnson [original], Todd Dukart [conversion]
     *
     * @param {String} hex Hex color string.
     * @return {Number} Red integer value.
     */

  }, {
    key: "hexToRed",
    value: function hexToRed(hex) {
      return parseInt(hex.substring(0, 2), 16);
    }
    /**
     * Parses a valid hex color string and returns the Green RGB integer value.
     *
     * @author Bryan Johnson [original], Todd Dukart [conversion]
     *
     * @param {String} hex Hex color string.
     * @return {Number} Green integer value.
     */

  }, {
    key: "hexToGreen",
    value: function hexToGreen(hex) {
      return parseInt(hex.substring(2, 4), 16);
    }
    /**
     * Parses a valid hex color string and returns the Blue RGB integer value.
     *
     * @author Bryan Johnson [original], Todd Dukart [conversion]
     *
     * @param {String} hex Hex color string.
     * @return {Number} Blue integer value.
     */

  }, {
    key: "hexToBlue",
    value: function hexToBlue(hex) {
      return parseInt(hex.substring(4, 6), 16);
    }
    /**
     * Converts a valid hex color string to an RGB array.
     *
     * @author Bryan Johnson [original], Todd Dukart [conversion]
     *
     * @param {String} hex Hex color String (e.g. FF00FF)
     * @return {Array} Array containing R, G, B values
     */

  }, {
    key: "hexToRGB",
    value: function hexToRGB(hex) {
      hex = hex.replace(/[^0-9a-f]/g, '');
      return [ColorUtil.hexToRed(hex), ColorUtil.hexToGreen(hex), ColorUtil.hexToBlue(hex)];
    }
    /**
     * Converts an RGB component to a hex string.
     *
     * @author Bryan Johnson [original], Todd Dukart [conversion]
     *
     * @param {Number} component RGB value, integer between 0 and 255.
     * @returns {String} Hex value string (e.g. FF)
     */

  }, {
    key: "componentToHex",
    value: function componentToHex(component) {
      var hex = component.toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    }
    /**
     * Converts RGB color components to a valid hex color string.
     *
     * @author Bryan Johnson [original], Todd Dukart [conversion]
     *
     * @param {Number} red RGB red value, integer between 0 and 255.
     * @param {Number} green RGB green value, integer between 0 and 255.
     * @param {Number} blue RGB blue value, integer between 0 and 255.
     * @returns {String} Hex color string (e.g. FF0000)
     */

  }, {
    key: "rgbToHex",
    value: function rgbToHex(red, green, blue) {
      var redHex = ColorUtil.componentToHex(red);
      var greenHex = ColorUtil.componentToHex(green);
      var blueHex = ColorUtil.componentToHex(blue);
      return "".concat(redHex).concat(greenHex).concat(blueHex);
    }
    /**
     * Converts HSB to RGB. Borrowed from https://www.cs.rit.edu/~ncs/color/t_convert.html
     * @param {number} hue        Hue, integer between 0 and 65535.
     * @param {number} saturation Saturation, integer between 0 and 254.
     * @param {number} brightness Brightness, integer between 0 and 254.
     * @returns {number[]} Array of [red, green, blue]
     */

  }, {
    key: "hsbToRgb",
    value: function hsbToRgb(hue, saturation, brightness) {
      var red;
      var green;
      var blue;
      hue = fitIntoRange(hue, 65535);

      if (0 === saturation) {
        red = green = blue = brightness;
      } else {
        var huePartial = hue / (65535 / 6); // There are six "sectors" in the hue, corresponding to the six primary colors.

        var sector = Math.floor(huePartial);
        var fractionalHue = huePartial - sector;
        var p = brightness / 254 * (254 - saturation);
        var q = brightness / 254 * (254 - saturation * fractionalHue);
        var t = brightness / 254 * (254 - saturation * (1 - fractionalHue));

        switch (sector) {
          case 0:
            red = brightness;
            green = t;
            blue = p;
            break;

          case 1:
            red = q;
            green = brightness;
            blue = p;
            break;

          case 2:
            red = p;
            green = brightness;
            blue = t;
            break;

          case 3:
            red = p;
            green = q;
            blue = brightness;
            break;

          case 4:
            red = t;
            green = p;
            blue = brightness;
            break;

          case 5:
            red = brightness;
            green = p;
            blue = q;
            break;
        }
      }

      return [Math.round(red), Math.round(green), Math.round(blue)];
    }
    /**
     * Converts RGB to HSB. Adapted from https://www.cs.rit.edu/~ncs/color/t_convert.html
     * @param {number} red   The red value, from 0 to 255.
     * @param {number} green The green value, from 0 to 255.
     * @param {number} blue  The blue value, from 0 to 255.
     * @returns {number[]} Array of [hue, saturation, brightness]. For shades of gray, hue will be undefined.
     */

  }, {
    key: "rgbToHsb",
    value: function rgbToHsb(red, green, blue) {
      var hue;
      var saturation;
      var brightness;
      var min = Math.min(red, green, blue);
      var max = Math.max(red, green, blue);
      brightness = max;
      var delta = max - min;

      if (max <= 0) {
        // It's black.
        hue = undefined; // Technically, black has no hue.

        saturation = brightness = 0;
      } else if (min >= 254) {
        //It's white.
        hue = undefined; // Technically, white has no hue.

        saturation = 0;
        brightness = 254;
      } else {
        saturation = delta / max * 254;

        if (saturation === 0) {
          hue = undefined; // Pure gray, so there's no hue.
        } else {
          if (red === max) {
            hue = (green - blue) / delta;
          } else if (green === max) {
            hue = 2 + (blue - red) / delta;
          } else {
            hue = 4 + (red - green) / delta;
          }

          hue = hue * (65535 / 6); // convert to Hue's 0-65535 range

          hue = fitIntoRange(hue, 65535);
          hue = Math.round(hue);
        }
      }

      saturation = Math.min(Math.round(saturation), 254);
      brightness = Math.min(Math.round(brightness), 254);
      return [hue, saturation, brightness];
    }
    /**
     * Returns a rgb array for given x, y values. Not actually an inverse of
     * getXYPointFromRGB. Implementation of the instructions found on the
     * Philips Hue iOS SDK docs: http://goo.gl/kWKXKl
     *
     * @author Q42 [original C#] Bryan Johnson [original JavaScript], Todd Dukart [conversion]
     *
     * @param {Number} x
     * @param {Number} y
     * @param {Number} brightness
     * @returns {Number[]}
     */

  }, {
    key: "getRGBFromXYAndBrightness",
    value: function getRGBFromXYAndBrightness(x, y, brightness) {
      var xyPoint = new XYPoint(x, y);

      if (brightness === undefined) {
        brightness = 254;
      } // Check if the xy value is within the color gamut of the lamp.
      // If not continue with step 2, otherwise step 3.
      // We do this to calculate the most accurate color the given light can actually do.


      if (!ColorUtil.isInLampsReach(xyPoint)) {
        // Calculate the closest point on the color gamut triangle
        // and use that as xy value See step 6 of color to xy.
        xyPoint = ColorUtil.getClosestReproduciblePoint(xyPoint);
      } // Calculate XYZ values Convert using the following formulas:


      var Y = brightness / 254;
      var X = Y / xyPoint.y * xyPoint.x;
      var Z = Y / xyPoint.y * (1 - xyPoint.x - xyPoint.y); // Convert to RGB using Wide RGB D65 conversion.

      var rgb = [X * 1.612 - Y * 0.203 - Z * 0.302, -X * 0.509 + Y * 1.412 + Z * 0.066, X * 0.026 - Y * 0.072 + Z * 0.962]; // Apply reverse gamma correction.

      rgb = rgb.map(function (x) {
        return x <= 0.0031308 ? 12.92 * x : (1.0 + 0.055) * Math.pow(x, 1.0 / 2.4) - 0.055;
      }); // Bring all negative components to zero.

      rgb = rgb.map(function (x) {
        return Math.max(0, x);
      }); // If one component is greater than 1, weight components by that value.

      var max = Math.max(rgb[0], rgb[1], rgb[2]);

      if (max > 1) {
        rgb = rgb.map(function (x) {
          return x / max;
        });
      }

      rgb = rgb.map(function (x) {
        return Math.floor(x * 255);
      });
      return rgb;
    }
    /**
     * Convert a mired color temperature to RGB. Adapted from http://www.tannerhelland.com/4435/convert-temperature-rgb-algorithm-code/.
     * @param {number} miredColorTemperature
     * @param {number} brightness
     * @returns {number[]}
     */

  }, {
    key: "miredToRgb",
    value: function miredToRgb(miredColorTemperature, brightness) {
      var kelvin = 1000000 / miredColorTemperature;
      var red;
      var green;
      var blue; // Calculate each color separately. Red:

      if (kelvin < 6600) {
        red = 255;
      } else {
        red = kelvin / 100 - 60;
        red = 329.698727446 * red ^ -0.1332047592;
      } // Green:


      if (kelvin < 6600) {
        green = kelvin / 100;
        green = 99.4708025861 * Math.log(green) - 161.1195681661;
      } else {
        green = kelvin / 100 - 60;
        green = 288.1221695283 * green ^ -0.0755148492;
      } // Blue:


      if (kelvin >= 6600) {
        blue = 255;
      } else {
        blue = kelvin - 10;
        blue = 138.5177312231 * Math.log(blue) - 305.0447927307;
      }

      var result = [red, green, blue];
      result = result.map(function (value) {
        value = Math.min(255, value);
        value = Math.max(0, value);
        value = value * (brightness / 254);
        return Math.round(value);
      });
      return result;
    }
    /**
     * Returns an XYPoint object containing the closest available CIE 1931
     * coordinates based on the RGB input values.
     *
     * @author Q42 [original C#] Bryan Johnson [original JavaScript], Todd Dukart [conversion]
     *
     * @param {Number} red RGB red value, integer between 0 and 255.
     * @param {Number} green RGB green value, integer between 0 and 255.
     * @param {Number} blue RGB blue value, integer between 0 and 255.
     * @return {XYPoint} CIE 1931 XY coordinates, corrected for reproducibility.
     */

  }, {
    key: "getXYPointFromRGB",
    value: function getXYPointFromRGB(red, green, blue) {
      var r = red > 0.04045 ? Math.pow((red + 0.055) / (1.0 + 0.055), 2.4) : red / 12.92;
      var g = green > 0.04045 ? Math.pow((green + 0.055) / (1.0 + 0.055), 2.4) : green / 12.92;
      var b = blue > 0.04045 ? Math.pow((blue + 0.055) / (1.0 + 0.055), 2.4) : blue / 12.92;
      var X = r * 0.4360747 + g * 0.3850649 + b * 0.0930804;
      var Y = r * 0.2225045 + g * 0.7168786 + b * 0.0406169;
      var Z = r * 0.0139322 + g * 0.0971045 + b * 0.7141733;
      var cx = X / (X + Y + Z);
      var cy = Y / (X + Y + Z);
      cx = isNaN(cx) ? 0.0 : cx;
      cy = isNaN(cy) ? 0.0 : cy; //Check if the given XY value is within the colourreach of our lamps.

      var xyPoint = new XYPoint(cx, cy);
      var inReachOfLamps = ColorUtil.isInLampsReach(xyPoint);

      if (!inReachOfLamps) {
        var closestPoint = ColorUtil.getClosestReproduciblePoint(xyPoint);
        cx = closestPoint.x;
        cy = closestPoint.y;
      }

      return new XYPoint(cx, cy);
    }
    /**
     * Get the approximate luminance from RGB
     *
     * @author Todd Dukart
     *
     * @param {Number} red
     * @param {Number} green
     * @param {Number} blue
     * @returns {Number}
     */

  }, {
    key: "getBrightnessFromRgb",
    value: function getBrightnessFromRgb(red, green, blue) {
      var brightness = parseInt(0.2126 * red + 0.7152 * green + 0.0722 * blue);
      brightness = Math.min(254, brightness);
      brightness = Math.max(1, brightness);
      return brightness;
    }
  }]);

  return ColorUtil;
}();

var COLOR_RGB = 'rgb';
var COLOR_CIE = 'cie';
var COLOR_CT = 'ct';
var COLOR_HSB = 'hsb';

var HueColor = /*#__PURE__*/function () {
  /**
   * Constructs a new Color. Should usually be called by one of the static from___ methods.
   */
  function HueColor() {
    _classCallCheck(this, HueColor);

    this.red = null;
    this.green = null;
    this.blue = null;
    this.x = null;
    this.y = null;
    this.brightness = null;
    this.hue = null;
    this.saturation = null;
    this.temperature = null;
    this.originalColor = null;
  }
  /**
   * Constructs a new Color given red, green, and blue.
   * @param {Number} red   The red value, from 0 to 255.
   * @param {Number} green The green value, from 0 to 255.
   * @param {Number} blue  The blue value, from 0 to 255.
   * @returns {HueColor}
   */


  _createClass(HueColor, [{
    key: "toRgb",

    /**
     * Converts the color to RGB. Note that the CIE-to-RGB conversion is necessarily approximate.
     * @returns {Number[]} Red, green, and blue components.
     */
    value: function toRgb() {
      var rgb = [null, null, null];

      if (null === this.red || null === this.green || null === this.blue) {
        switch (this.originalColor) {
          case COLOR_CIE:
            rgb = ColorUtil.getRGBFromXYAndBrightness(this.x, this.y, this.brightness);
            break;

          case COLOR_HSB:
            rgb = ColorUtil.hsbToRgb(this.hue, this.saturation, this.brightness);
            break;

          case COLOR_CT:
            rgb = ColorUtil.miredToRgb(this.temperature, this.brightness);
            break;

          default:
            throw new Error('Unable to process color, original is ' + this.originalColor);
        }
      }

      if (null !== rgb[0]) {
        this.red = rgb[0];
        this.green = rgb[1];
        this.blue = rgb[2];
      }

      return [this.red, this.green, this.blue];
    }
    /**
     * Converts the color to a CSS-style hex string. Note that the CIE-to-RGB conversion is necessarily approximate.
     * @returns {String}
     */

  }, {
    key: "toHex",
    value: function toHex() {
      var rgb = this.toRgb();
      return ColorUtil.rgbToHex(rgb[0], rgb[1], rgb[2]);
    }
    /**
     * Converts the color to a CIE color that Hue lamps are capable of showing. Note that the RGB-to-CIE conversion is
     * necessarily approximate.
     * @returns {Number[]} X, Y, and brightness components.
     */

  }, {
    key: "toCie",
    value: function toCie() {
      var cie = {
        x: null,
        y: null
      };
      var rgb;

      if (null === this.x || null === this.y || null === this.brightness) {
        switch (this.originalColor) {
          case COLOR_RGB:
            cie = ColorUtil.getXYPointFromRGB(this.red, this.green, this.blue);
            this.brightness = ColorUtil.getBrightnessFromRgb(this.red, this.green, this.blue);
            break;

          case COLOR_HSB:
            rgb = ColorUtil.hsbToRgb(this.hue, this.saturation, this.brightness);
            cie = ColorUtil.getXYPointFromRGB(rgb[0], rgb[1], rgb[2]); // We already know the brightness :-)

            break;

          case COLOR_CT:
            rgb = ColorUtil.miredToRgb(this.temperature, this.brightness);
            cie = ColorUtil.getXYPointFromRGB(rgb[0], rgb[1], rgb[2]);
            break;

          default:
            throw new Error('Unable to process color, original is ' + this.originalColor);
        }
      }

      if (null !== cie.x) {
        this.x = cie.x;
        this.y = cie.y;
      }

      return [this.x, this.y, this.brightness];
    }
    /**
     * Converts the color to HSB.
     * @returns {Number[]}
     */

  }, {
    key: "toHsb",
    value: function toHsb() {
      var hsb = [null, null, null];

      if (null === this.hue || null === this.saturation) {
        var rgb = this.toRgb();
        hsb = ColorUtil.rgbToHsb(rgb[0], rgb[1], rgb[2]);
      } // Hue can be null-ish, so check saturation instead.


      if (null !== hsb[1]) {
        this.hue = hsb[0];
        this.saturation = hsb[1];
        this.brightness = hsb[2];
      }

      return [this.hue, this.saturation, this.brightness];
    }
  }, {
    key: "toCt",
    value: function toCt() {
      if (COLOR_CT !== this.originalColor) {
        return undefined;
      } else {
        return this.temperature;
      }
    }
  }], [{
    key: "fromRgb",
    value: function fromRgb(red, green, blue) {
      var color = new HueColor();
      color.red = red;
      color.green = green;
      color.blue = blue;
      color.originalColor = COLOR_RGB;
      return color;
    }
    /**
     * Constructs a new Color given a CIE point and brightness.
     * @param {Number} x          X coordinate.
     * @param {Number} y          Y coordinate.
     * @param {Number} brightness Brightness, from 0 to 254.
     * @returns {HueColor}
     */

  }, {
    key: "fromCIE",
    value: function fromCIE(x, y, brightness) {
      var color = new HueColor();
      color.x = x;
      color.y = y;
      color.brightness = brightness;
      color.originalColor = COLOR_CIE;
      return color;
    }
  }, {
    key: "fromCt",
    value: function fromCt(colorTemperature, brightness) {
      var color = new HueColor();
      color.temperature = colorTemperature;
      color.brightness = brightness;
      color.originalColor = COLOR_CT;
      return color;
    }
    /**
     * Constructs a new Color given a CSS-style hex code.
     * @param {String} hex The hex code.
     * @returns {HueColor}
     */

  }, {
    key: "fromHex",
    value: function fromHex(hex) {
      var rgb = ColorUtil.hexToRGB(hex);
      return HueColor.fromRgb(rgb[0], rgb[1], rgb[2]);
    }
    /**
     * Constructs a new Color given HSB values.
     * @param {number} hue        Integer, 0 to 65535
     * @param {number} saturation Integer, 0 to 254
     * @param {number} brightness Integer, 0 to 254
     * @returns {HueColor}
     */

  }, {
    key: "fromHsb",
    value: function fromHsb(hue, saturation, brightness) {
      var color = new HueColor();
      color.hue = hue;
      color.saturation = saturation;
      color.brightness = brightness;
      color.originalColor = COLOR_HSB;
      return color;
    }
  }]);

  return HueColor;
}();

export default HueColor;
//# sourceMappingURL=index.es.js.map
